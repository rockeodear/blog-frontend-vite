import {
  require_safe
} from "./chunk-6EQFNKA7.js";
import {
  require_factory_space,
  require_prefix_size
} from "./chunk-26AS2OEM.js";
import {
  require_repeat_string
} from "./chunk-AWYOROPT.js";
import {
  __commonJS,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-XTN4ZABK.js";

// node_modules/micromark-extension-math/lib/tokenize-math-flow.js
var require_tokenize_math_flow = __commonJS({
  "node_modules/micromark-extension-math/lib/tokenize-math-flow.js"(exports) {
    "use strict";
    exports.tokenize = tokenizeMathFenced;
    exports.concrete = true;
    var prefixSize = require_prefix_size();
    var createSpace = require_factory_space();
    function tokenizeMathFenced(effects, ok, nok) {
      var self = this;
      var initialPrefix = prefixSize(this.events, "linePrefix");
      var sizeOpen = 0;
      return start;
      function start(code) {
        if (code !== 36)
          throw new Error("expected `$`");
        effects.enter("mathFlow");
        effects.enter("mathFlowFence");
        effects.enter("mathFlowFenceSequence");
        return sequenceOpen(code);
      }
      function sequenceOpen(code) {
        if (code === 36) {
          effects.consume(code);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("mathFlowFenceSequence");
        return sizeOpen < 2 ? nok(code) : createSpace(effects, metaOpen, "whitespace")(code);
      }
      function metaOpen(code) {
        if (code === null || code === -5 || code === -4 || code === -3) {
          return openAfter(code);
        }
        effects.enter("mathFlowFenceMeta");
        effects.enter("chunkString", { contentType: "string" });
        return meta(code);
      }
      function meta(code) {
        if (code === null || code === -5 || code === -4 || code === -3) {
          effects.exit("chunkString");
          effects.exit("mathFlowFenceMeta");
          return openAfter(code);
        }
        if (code === 36)
          return nok(code);
        effects.consume(code);
        return meta;
      }
      function openAfter(code) {
        effects.exit("mathFlowFence");
        return self.interrupt ? ok(code) : content(code);
      }
      function content(code) {
        if (code === null) {
          return after(code);
        }
        if (code === -5 || code === -4 || code === -3) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return effects.attempt({ tokenize: tokenizeClosingFence, partial: true }, after, initialPrefix ? createSpace(effects, content, "linePrefix", initialPrefix + 1) : content);
        }
        effects.enter("mathFlowValue");
        return contentContinue(code);
      }
      function contentContinue(code) {
        if (code === null || code === -5 || code === -4 || code === -3) {
          effects.exit("mathFlowValue");
          return content(code);
        }
        effects.consume(code);
        return contentContinue;
      }
      function after(code) {
        effects.exit("mathFlow");
        return ok(code);
      }
      function tokenizeClosingFence(effects2, ok2, nok2) {
        var size = 0;
        return createSpace(effects2, closingPrefixAfter, "linePrefix", 4);
        function closingPrefixAfter(code) {
          effects2.enter("mathFlowFence");
          effects2.enter("mathFlowFenceSequence");
          return closingSequence(code);
        }
        function closingSequence(code) {
          if (code === 36) {
            effects2.consume(code);
            size++;
            return closingSequence;
          }
          if (size < sizeOpen)
            return nok2(code);
          effects2.exit("mathFlowFenceSequence");
          return createSpace(effects2, closingSequenceEnd, "whitespace")(code);
        }
        function closingSequenceEnd(code) {
          if (code === null || code === -5 || code === -4 || code === -3) {
            effects2.exit("mathFlowFence");
            return ok2(code);
          }
          return nok2(code);
        }
      }
    }
  }
});

// node_modules/micromark-extension-math/lib/tokenize-math-text.js
var require_tokenize_math_text = __commonJS({
  "node_modules/micromark-extension-math/lib/tokenize-math-text.js"(exports) {
    "use strict";
    exports.tokenize = tokenizeMathText;
    exports.resolve = resolveMathText;
    exports.previous = previous;
    function resolveMathText(events) {
      var tailExitIndex = events.length - 4;
      var headEnterIndex = 3;
      var index;
      var enter;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index = headEnterIndex;
        while (++index < tailExitIndex) {
          if (events[index][1].type === "mathTextData") {
            events[tailExitIndex][1].type = "mathTextPadding";
            events[headEnterIndex][1].type = "mathTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index = headEnterIndex - 1;
      tailExitIndex++;
      while (++index <= tailExitIndex) {
        if (enter === void 0) {
          if (index !== tailExitIndex && events[index][1].type !== "lineEnding") {
            enter = index;
          }
        } else if (index === tailExitIndex || events[index][1].type === "lineEnding") {
          events[enter][1].type = "mathTextData";
          if (index !== enter + 2) {
            events[enter][1].end = events[index - 1][1].end;
            events.splice(enter + 2, index - enter - 2);
            tailExitIndex -= index - enter - 2;
            index = enter + 2;
          }
          enter = void 0;
        }
      }
      return events;
    }
    function previous(code) {
      return code !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeMathText(effects, ok, nok) {
      var self = this;
      var sizeOpen = 0;
      var size;
      var token;
      return start;
      function start(code) {
        if (code !== 36)
          throw new Error("expected `$`");
        if (!previous.call(self, self.previous)) {
          throw new Error("expected correct previous");
        }
        effects.enter("mathText");
        effects.enter("mathTextSequence");
        return openingSequence(code);
      }
      function openingSequence(code) {
        if (code === 36) {
          effects.consume(code);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("mathTextSequence");
        return gap(code);
      }
      function gap(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 36) {
          token = effects.enter("mathTextSequence");
          size = 0;
          return closingSequence(code);
        }
        if (code === 32) {
          effects.enter("space");
          effects.consume(code);
          effects.exit("space");
          return gap;
        }
        if (code === -5 || code === -4 || code === -3) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return gap;
        }
        effects.enter("mathTextData");
        return data(code);
      }
      function data(code) {
        if (code === null || code === 32 || code === 36 || code === -5 || code === -4 || code === -3) {
          effects.exit("mathTextData");
          return gap(code);
        }
        effects.consume(code);
        return data;
      }
      function closingSequence(code) {
        if (code === 36) {
          effects.consume(code);
          size++;
          return closingSequence;
        }
        if (size === sizeOpen) {
          effects.exit("mathTextSequence");
          effects.exit("mathText");
          return ok(code);
        }
        token.type = "mathTextData";
        return data(code);
      }
    }
  }
});

// node_modules/micromark-extension-math/lib/syntax.js
var require_syntax = __commonJS({
  "node_modules/micromark-extension-math/lib/syntax.js"(exports) {
    "use strict";
    exports.flow = { 36: require_tokenize_math_flow() };
    exports.text = { 36: require_tokenize_math_text() };
  }
});

// node_modules/micromark-extension-math/index.js
var require_micromark_extension_math = __commonJS({
  "node_modules/micromark-extension-math/index.js"(exports, module) {
    module.exports = require_syntax();
  }
});

// node_modules/mdast-util-math/from-markdown.js
var require_from_markdown = __commonJS({
  "node_modules/mdast-util-math/from-markdown.js"(exports) {
    "use strict";
    exports.enter = {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    };
    exports.exit = {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    };
    function enterMathFlow(token) {
      this.enter({
        type: "math",
        meta: null,
        value: "",
        data: {
          hName: "div",
          hProperties: { className: ["math", "math-display"] },
          hChildren: [{ type: "text", value: "" }]
        }
      }, token);
    }
    function enterMathFlowMeta() {
      this.buffer();
    }
    function exitMathFlowMeta() {
      var data = this.resume();
      this.stack[this.stack.length - 1].meta = data;
    }
    function exitMathFlowFence() {
      if (this.getData("mathFlowInside"))
        return;
      this.buffer();
      this.setData("mathFlowInside", true);
    }
    function exitMathFlow(token) {
      var data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      var node = this.exit(token);
      node.value = data;
      node.data.hChildren[0].value = data;
      this.setData("mathFlowInside");
    }
    function enterMathText(token) {
      this.enter({
        type: "inlineMath",
        value: "",
        data: {
          hName: "span",
          hProperties: { className: ["math", "math-inline"] },
          hChildren: [{ type: "text", value: "" }]
        }
      }, token);
      this.buffer();
    }
    function exitMathText(token) {
      var data = this.resume();
      var node = this.exit(token);
      node.value = data;
      node.data.hChildren[0].value = data;
    }
    function exitMathData(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
  }
});

// node_modules/longest-streak/index.js
var require_longest_streak = __commonJS({
  "node_modules/longest-streak/index.js"(exports, module) {
    "use strict";
    module.exports = longestStreak;
    function longestStreak(value, character) {
      var count = 0;
      var maximum = 0;
      var expected;
      var index;
      if (typeof character !== "string" || character.length !== 1) {
        throw new Error("Expected character");
      }
      value = String(value);
      index = value.indexOf(character);
      expected = index;
      while (index !== -1) {
        count++;
        if (index === expected) {
          if (count > maximum) {
            maximum = count;
          }
        } else {
          count = 1;
        }
        expected = index + 1;
        index = value.indexOf(character, expected);
      }
      return maximum;
    }
  }
});

// node_modules/mdast-util-math/to-markdown.js
var require_to_markdown = __commonJS({
  "node_modules/mdast-util-math/to-markdown.js"(exports) {
    "use strict";
    exports.unsafe = [
      { character: "\r", inConstruct: ["mathFlowMeta"] },
      { character: "\r", inConstruct: ["mathFlowMeta"] },
      { character: "$", inConstruct: ["mathFlowMeta", "phrasing"] },
      { atBreak: true, character: "$", after: "\\$" }
    ];
    exports.handlers = { math: math2, inlineMath };
    inlineMath.peek = inlineMathPeek;
    var repeat = require_repeat_string();
    var streak = require_longest_streak();
    var safe = require_safe();
    function math2(node, _, context) {
      var raw = node.value || "";
      var fence = repeat("$", Math.max(streak(raw, "$") + 1, 2));
      var exit = context.enter("mathFlow");
      var value = fence;
      var subexit;
      if (node.meta) {
        subexit = context.enter("mathFlowMeta");
        value += safe(context, node.meta, { before: "$", after: " ", encode: ["$"] });
        subexit();
      }
      value += "\n";
      if (raw) {
        value += raw + "\n";
      }
      value += fence;
      exit();
      return value;
    }
    function inlineMath(node) {
      var value = node.value || "";
      var size = 1;
      var pad = "";
      var sequence;
      while (new RegExp("(^|[^$])" + repeat("\\$", size) + "([^$]|$)").test(value)) {
        size++;
      }
      if (/[^ \r\n]/.test(value) && (/[ \r\n$]/.test(value.charAt(0)) || /[ \r\n$]/.test(value.charAt(value.length - 1)))) {
        pad = " ";
      }
      sequence = repeat("$", size);
      return sequence + pad + value + pad + sequence;
    }
    function inlineMathPeek() {
      return "$";
    }
  }
});

// node_modules/remark-math/index.js
var require_remark_math = __commonJS({
  "node_modules/remark-math/index.js"(exports, module) {
    "use strict";
    var syntax = require_micromark_extension_math();
    var fromMarkdown = require_from_markdown();
    var toMarkdown = require_to_markdown();
    var warningIssued;
    module.exports = math2;
    function math2() {
      var data = this.data();
      if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
        warningIssued = true;
        console.warn("[remark-math] Warning: please upgrade to remark 13 to use this plugin");
      }
      add("micromarkExtensions", syntax);
      add("fromMarkdownExtensions", fromMarkdown);
      add("toMarkdownExtensions", toMarkdown);
      function add(field, value) {
        if (data[field])
          data[field].push(value);
        else
          data[field] = [value];
      }
    }
  }
});

// node_modules/@bytemd/plugin-math/dist/index.esm.js
var import_remark_math = __toModule(require_remark_math());
var icons = {
  math: '<svg width="1em" height="1em" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m40 9-3-3H8l18 18L8 42h29l3-3" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  inline: '<svg width="1em" height="1em" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m37 9-3-3H8l17 18L8 42h26l3-3M5 24h10M33 24h10" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  block: '<svg width="1em" height="1em" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m36 11-3-3H12l16 16-16 16h21l3-3M6 5v38M42 5v38" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>'
};
var inline = "Inline formula";
var inlineText = "formula";
var block = "Block formula";
var blockText = "formula";
var en = {
  inline,
  inlineText,
  block,
  blockText
};
function math({ locale: _locale, katexOptions } = {}) {
  const locale = __spreadValues(__spreadValues({}, en), _locale);
  let katex;
  return {
    remark: (p) => p.use(import_remark_math.default),
    viewerEffect({ markdownBody }) {
      const renderMath = async (selector, displayMode) => {
        const els = markdownBody.querySelectorAll(selector);
        if (els.length === 0)
          return;
        if (!katex) {
          katex = await import("./katex-RGKR7SX7.js");
        }
        els.forEach((el) => {
          katex.render(el.innerText, el, __spreadProps(__spreadValues({}, katexOptions), {
            throwOnError: false,
            displayMode
          }));
        });
      };
      renderMath(".math.math-inline", false);
      renderMath(".math.math-display", true);
    },
    actions: [
      {
        icon: icons.math,
        handler: {
          type: "dropdown",
          actions: [
            {
              title: locale.inline,
              icon: icons.inline,
              cheatsheet: `$${locale.inlineText}$`,
              handler: {
                type: "action",
                click({ wrapText, editor }) {
                  wrapText("$");
                  editor.focus();
                }
              }
            },
            {
              title: locale.block,
              icon: icons.block,
              cheatsheet: `$$\u21B5${locale.blockText}\u21B5$$`,
              handler: {
                type: "action",
                click({ appendBlock, editor, codemirror }) {
                  const { line } = appendBlock("$$\n\\TeX\n$$");
                  editor.setSelection(codemirror.Pos(line + 1, 0), codemirror.Pos(line + 1, 4));
                  editor.focus();
                }
              }
            }
          ]
        }
      }
    ]
  };
}

export {
  require_remark_math,
  math
};
//# sourceMappingURL=chunk-B4ODCUXW.js.map

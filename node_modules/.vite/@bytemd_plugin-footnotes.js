import {
  require_decode_entity_browser,
  require_normalize_identifier,
  require_partial_blank_line
} from "./chunk-YIOIGQ2I.js";
import {
  require_container_flow,
  require_container_phrasing,
  require_indent_lines
} from "./chunk-GMGKG6NX.js";
import {
  require_chunked_splice,
  require_resolve_all,
  require_shallow
} from "./chunk-3HYEFTOO.js";
import {
  require_safe
} from "./chunk-6EQFNKA7.js";
import "./chunk-SMIMVPOE.js";
import {
  require_factory_space,
  require_prefix_size
} from "./chunk-26AS2OEM.js";
import "./chunk-AWYOROPT.js";
import {
  __commonJS,
  __toModule
} from "./chunk-XTN4ZABK.js";

// node_modules/micromark-extension-footnote/index.js
var require_micromark_extension_footnote = __commonJS({
  "node_modules/micromark-extension-footnote/index.js"(exports, module) {
    module.exports = footnote;
    var normalizeIdentifier = require_normalize_identifier();
    var blank = require_partial_blank_line();
    var createSpace = require_factory_space();
    var chunkedSplice = require_chunked_splice();
    var prefixSize = require_prefix_size();
    var shallow = require_shallow();
    var resolveAll = require_resolve_all();
    var indent = { tokenize: tokenizeIndent, partial: true };
    function footnote(options) {
      var settings = options || {};
      var call = { tokenize: tokenizeFootnoteCall };
      var noteStart = { tokenize: tokenizeNoteStart, resolveAll: resolveAllNote };
      var noteEnd = {
        add: "after",
        tokenize: tokenizeNoteEnd,
        resolveAll: resolveAllNote,
        resolveTo: resolveToNoteEnd
      };
      var definition = {
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: footnoteDefinitionEnd
      };
      var text = { 91: call };
      if (settings.inlineNotes) {
        text[93] = noteEnd;
        text[94] = noteStart;
      }
      return {
        _hiddenFootnoteSupport: {},
        document: { 91: definition },
        text
      };
    }
    function resolveAllNote(events) {
      var length = events.length;
      var index = -1;
      var token;
      while (++index < length) {
        token = events[index][1];
        if (events[index][0] === "enter" && token.type === "inlineNoteStart") {
          token.type = "data";
          events.splice(index + 1, 4);
          length -= 4;
        }
      }
      return events;
    }
    function resolveToNoteEnd(events, context) {
      var index = events.length - 4;
      var group;
      var text;
      var token;
      var type;
      var openIndex;
      while (index--) {
        token = events[index][1];
        if (events[index][0] === "enter" && token.type === "inlineNoteStart") {
          openIndex = index;
          type = "inlineNote";
          break;
        }
      }
      group = {
        type,
        start: shallow(events[openIndex][1].start),
        end: shallow(events[events.length - 1][1].end)
      };
      text = {
        type: "inlineNoteText",
        start: shallow(events[openIndex + 4][1].end),
        end: shallow(events[events.length - 3][1].start)
      };
      var note = [
        ["enter", group, context],
        events[openIndex + 1],
        events[openIndex + 2],
        events[openIndex + 3],
        events[openIndex + 4],
        ["enter", text, context]
      ];
      chunkedSplice(note, note.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(openIndex + 6, -4), context));
      note.push(["exit", text, context], events[events.length - 2], events[events.length - 3], ["exit", group, context]);
      chunkedSplice(events, index, events.length - index, note);
      return events;
    }
    function tokenizeFootnoteCall(effects, ok, nok) {
      var self = this;
      var defined = self.parser.footnotes || (self.parser.footnotes = []);
      var size = 0;
      var data;
      return start;
      function start(code) {
        if (code !== 91)
          return nok(code);
        effects.enter("footnoteCall");
        effects.enter("footnoteCallLabelMarker");
        effects.consume(code);
        effects.exit("footnoteCallLabelMarker");
        return callStart;
      }
      function callStart(code) {
        if (code !== 94)
          return nok(code);
        effects.enter("footnoteCallMarker");
        effects.consume(code);
        effects.exit("footnoteCallMarker");
        effects.enter("footnoteCallString");
        effects.enter("chunkString").contentType = "string";
        return callData;
      }
      function callData(code) {
        var token;
        if (code === null || code === 91 || size++ > 999) {
          return nok(code);
        }
        if (code === 93) {
          if (!data) {
            return nok(code);
          }
          effects.exit("chunkString");
          token = effects.exit("footnoteCallString");
          return defined.indexOf(normalizeIdentifier(self.sliceSerialize(token))) < 0 ? nok(code) : end(code);
        }
        effects.consume(code);
        if (!(code < 0 || code === 32)) {
          data = true;
        }
        return code === 92 ? callEscape : callData;
      }
      function callEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return callData;
        }
        return callData(code);
      }
      function end(code) {
        effects.enter("footnoteCallLabelMarker");
        effects.consume(code);
        effects.exit("footnoteCallLabelMarker");
        effects.exit("footnoteCall");
        return ok;
      }
    }
    function tokenizeNoteStart(effects, ok, nok) {
      return start;
      function start(code) {
        if (code !== 94)
          return nok(code);
        effects.enter("inlineNoteStart");
        effects.enter("inlineNoteMarker");
        effects.consume(code);
        effects.exit("inlineNoteMarker");
        return noteStart;
      }
      function noteStart(code) {
        if (code !== 91)
          return nok(code);
        effects.enter("inlineNoteStartMarker");
        effects.consume(code);
        effects.exit("inlineNoteStartMarker");
        effects.exit("inlineNoteStart");
        return ok;
      }
    }
    function tokenizeNoteEnd(effects, ok, nok) {
      var self = this;
      return start;
      function start(code) {
        var index = self.events.length;
        var hasStart;
        while (index--) {
          if (self.events[index][1].type === "inlineNoteStart") {
            hasStart = true;
            break;
          }
        }
        if (code !== 93 || !hasStart) {
          return nok(code);
        }
        effects.enter("inlineNoteEnd");
        effects.enter("inlineNoteEndMarker");
        effects.consume(code);
        effects.exit("inlineNoteEndMarker");
        effects.exit("inlineNoteEnd");
        return ok;
      }
    }
    function tokenizeDefinitionStart(effects, ok, nok) {
      var self = this;
      var defined = self.parser.footnotes || (self.parser.footnotes = []);
      var identifier;
      var size = 0;
      var data;
      return start;
      function start(code) {
        if (code !== 91) {
          return nok(code);
        }
        effects.enter("footnoteDefinition")._container = true;
        effects.enter("footnoteDefinitionLabel");
        effects.enter("footnoteDefinitionLabelMarker");
        effects.consume(code);
        effects.exit("footnoteDefinitionLabelMarker");
        return labelStart;
      }
      function labelStart(code) {
        if (code !== 94)
          return nok(code);
        effects.enter("footnoteDefinitionMarker");
        effects.consume(code);
        effects.exit("footnoteDefinitionMarker");
        effects.enter("footnoteDefinitionLabelString");
        return atBreak;
      }
      function atBreak(code) {
        var token;
        if (code === null || code === 91 || size > 999) {
          return nok(code);
        }
        if (code === 93) {
          if (!data) {
            return nok(code);
          }
          token = effects.exit("footnoteDefinitionLabelString");
          identifier = normalizeIdentifier(self.sliceSerialize(token));
          effects.enter("footnoteDefinitionLabelMarker");
          effects.consume(code);
          effects.exit("footnoteDefinitionLabelMarker");
          effects.exit("footnoteDefinitionLabel");
          return labelAfter;
        }
        if (code === -5 || code === -4 || code === -3) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          size++;
          return atBreak;
        }
        effects.enter("chunkString").contentType = "string";
        return label(code);
      }
      function label(code) {
        if (code === null || code === -5 || code === -4 || code === -3 || code === 91 || code === 93 || size > 999) {
          effects.exit("chunkString");
          return atBreak(code);
        }
        if (!(code < 0 || code === 32)) {
          data = true;
        }
        size++;
        effects.consume(code);
        return code === 92 ? labelEscape : label;
      }
      function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return label;
        }
        return label(code);
      }
      function labelAfter(code) {
        if (code !== 58) {
          return nok(code);
        }
        effects.enter("definitionMarker");
        effects.consume(code);
        effects.exit("definitionMarker");
        return effects.check(blank, onBlank, nonBlank);
      }
      function onBlank(code) {
        self.containerState.initialBlankLine = true;
        return done(code);
      }
      function nonBlank(code) {
        if (code === -2 || code === -1 || code === 32) {
          effects.enter("footnoteDefinitionWhitespace");
          effects.consume(code);
          effects.exit("footnoteDefinitionWhitespace");
          return done(code);
        }
        return done(code);
      }
      function done(code) {
        if (defined.indexOf(identifier) < 0) {
          defined.push(identifier);
        }
        return ok(code);
      }
    }
    function tokenizeDefinitionContinuation(effects, ok, nok) {
      var self = this;
      return effects.check(blank, onBlank, notBlank);
      function onBlank(code) {
        if (self.containerState.initialBlankLine) {
          self.containerState.furtherBlankLines = true;
        }
        return ok(code);
      }
      function notBlank(code) {
        if (self.containerState.furtherBlankLines || !(code === -2 || code === -1 || code === 32)) {
          return nok(code);
        }
        self.containerState.initialBlankLine = void 0;
        self.containerState.furtherBlankLines = void 0;
        return effects.attempt(indent, ok, nok)(code);
      }
    }
    function footnoteDefinitionEnd(effects) {
      effects.exit("footnoteDefinition");
    }
    function tokenizeIndent(effects, ok, nok) {
      var self = this;
      return createSpace(effects, afterPrefix, "footnoteDefinitionIndent", 5);
      function afterPrefix(code) {
        return prefixSize(self.events, "footnoteDefinitionIndent") === 4 ? ok(code) : nok(code);
      }
    }
  }
});

// node_modules/mdast-util-footnote/from-markdown.js
var require_from_markdown = __commonJS({
  "node_modules/mdast-util-footnote/from-markdown.js"(exports) {
    var normalizeIdentifier = require_normalize_identifier();
    exports.canContainEols = ["footnote"];
    exports.enter = {
      footnoteDefinition: enterFootnoteDefinition,
      footnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      footnoteCall: enterFootnoteCall,
      footnoteCallString: enterFootnoteCallString,
      inlineNote: enterNote
    };
    exports.exit = {
      footnoteDefinition: exitFootnoteDefinition,
      footnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      footnoteCall: exitFootnoteCall,
      footnoteCallString: exitFootnoteCallString,
      inlineNote: exitNote
    };
    function enterFootnoteDefinition(token) {
      this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
    }
    function enterFootnoteDefinitionLabelString() {
      this.buffer();
    }
    function exitFootnoteDefinitionLabelString(token) {
      var label = this.resume();
      this.stack[this.stack.length - 1].label = label;
      this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function exitFootnoteDefinition(token) {
      this.exit(token);
    }
    function enterFootnoteCall(token) {
      this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
    }
    function enterFootnoteCallString() {
      this.buffer();
    }
    function exitFootnoteCallString(token) {
      var label = this.resume();
      this.stack[this.stack.length - 1].label = label;
      this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function exitFootnoteCall(token) {
      this.exit(token);
    }
    function enterNote(token) {
      this.enter({ type: "footnote", children: [] }, token);
    }
    function exitNote(token) {
      this.exit(token);
    }
  }
});

// node_modules/mdast-util-to-markdown/lib/util/association.js
var require_association = __commonJS({
  "node_modules/mdast-util-to-markdown/lib/util/association.js"(exports, module) {
    module.exports = association;
    var decode = require_decode_entity_browser();
    var characterEscape = /\\([!-/:-@[-`{-~])/g;
    var characterReference = /&(#(\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    function association(node) {
      if (node.label || !node.identifier) {
        return node.label || "";
      }
      return node.identifier.replace(characterEscape, "$1").replace(characterReference, decodeIfPossible);
    }
    function decodeIfPossible($0, $1) {
      return decode($1) || $0;
    }
  }
});

// node_modules/mdast-util-footnote/to-markdown.js
var require_to_markdown = __commonJS({
  "node_modules/mdast-util-footnote/to-markdown.js"(exports) {
    exports.unsafe = [
      { character: "[", inConstruct: ["phrasing", "label", "reference"] }
    ];
    exports.handlers = {
      footnote,
      footnoteDefinition,
      footnoteReference
    };
    var association = require_association();
    var phrasing = require_container_phrasing();
    var flow = require_container_flow();
    var indentLines = require_indent_lines();
    var safe = require_safe();
    footnoteReference.peek = footnoteReferencePeek;
    footnote.peek = footnotePeek;
    function footnoteReference(node, _, context) {
      var exit = context.enter("footnoteReference");
      var subexit = context.enter("reference");
      var reference = safe(context, association(node), { before: "^", after: "]" });
      subexit();
      exit();
      return "[^" + reference + "]";
    }
    function footnoteReferencePeek() {
      return "[";
    }
    function footnote(node, _, context) {
      var exit = context.enter("footnote");
      var subexit = context.enter("label");
      var value = "^[" + phrasing(node, context, { before: "[", after: "]" }) + "]";
      subexit();
      exit();
      return value;
    }
    function footnotePeek() {
      return "^";
    }
    function footnoteDefinition(node, _, context) {
      var exit = context.enter("footnoteDefinition");
      var subexit = context.enter("label");
      var label = "[^" + safe(context, association(node), { before: "^", after: "]" }) + "]:";
      var value;
      subexit();
      value = indentLines(flow(node, context), map);
      exit();
      return value;
      function map(line, index, blank) {
        if (index) {
          return (blank ? "" : "    ") + line;
        }
        return (blank ? label : label + " ") + line;
      }
    }
  }
});

// node_modules/remark-footnotes/index.js
var require_remark_footnotes = __commonJS({
  "node_modules/remark-footnotes/index.js"(exports, module) {
    "use strict";
    var syntax = require_micromark_extension_footnote();
    var fromMarkdown = require_from_markdown();
    var toMarkdown = require_to_markdown();
    var warningIssued;
    module.exports = footnotes2;
    function footnotes2(options) {
      var data = this.data();
      if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
        warningIssued = true;
        console.warn("[remark-footnotes] Warning: please upgrade to remark 13 to use this plugin");
      }
      add("micromarkExtensions", syntax(options));
      add("fromMarkdownExtensions", fromMarkdown);
      add("toMarkdownExtensions", toMarkdown);
      function add(field, value) {
        if (data[field])
          data[field].push(value);
        else
          data[field] = [value];
      }
    }
  }
});

// node_modules/@bytemd/plugin-footnotes/dist/index.esm.js
var import_remark_footnotes = __toModule(require_remark_footnotes());
function footnotes(options) {
  return {
    remark: (u) => u.use(import_remark_footnotes.default, options)
  };
}

// dep:@bytemd_plugin-footnotes
var bytemd_plugin_footnotes_default = footnotes;
export {
  bytemd_plugin_footnotes_default as default
};
//# sourceMappingURL=@bytemd_plugin-footnotes.js.map

{
  "version": 3,
  "sources": ["../micromark/dist/util/normalize-identifier.js", "../micromark/dist/tokenize/partial-blank-line.js", "../parse-entities/decode-entity.browser.js"],
  "sourcesContent": ["'use strict'\n\nfunction normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered \u201Cuppercase\u201D, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no object method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n\nmodule.exports = normalizeIdentifier\n", "'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\n\nvar partialBlankLine = {\n  tokenize: tokenizePartialBlankLine,\n  partial: true\n}\n\nfunction tokenizePartialBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n\nmodule.exports = partialBlankLine\n", "'use strict'\n\n/* eslint-env browser */\n\nvar el\n\nvar semicolon = 59 //  ';'\n\nmodule.exports = decodeEntity\n\nfunction decodeEntity(characters) {\n  var entity = '&' + characters + ';'\n  var char\n\n  el = el || document.createElement('i')\n  el.innerHTML = entity\n  char = el.textContent\n\n  // Some entities do not require the closing semicolon (`&not` - for instance),\n  // which leads to situations where parsing the assumed entity of &notit; will\n  // result in the string `\u00ACit;`.  When we encounter a trailing semicolon after\n  // parsing and the entity to decode was not a semicolon (`&semi;`), we can\n  // assume that the matching was incomplete\n  if (char.charCodeAt(char.length - 1) === semicolon && characters !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the entity was not valid\n  return char === entity ? false : char\n}\n"],
  "mappings": ";;;;;;;;;;;AAAA;AAAA;AAAA;AAEA,iCAA6B,OAAO;AAClC,aACE,MACG,QAAQ,eAAe,KACvB,QAAQ,UAAU,IAMlB,cACA;AAAA;AAIP,WAAO,UAAU;AAAA;AAAA;;;ACjBjB;AAAA;AAAA;AAEA,QAAI,qBAAqB;AACzB,QAAI,eAAe;AAEnB,QAAI,mBAAmB;AAAA,MACrB,UAAU;AAAA,MACV,SAAS;AAAA;AAGX,sCAAkC,SAAS,IAAI,KAAK;AAClD,aAAO,aAAa,SAAS,iBAAiB;AAE9C,+BAAyB,MAAM;AAC7B,eAAO,SAAS,QAAQ,mBAAmB,QAAQ,GAAG,QAAQ,IAAI;AAAA;AAAA;AAItE,WAAO,UAAU;AAAA;AAAA;;;AClBjB;AAAA;AAAA;AAIA,QAAI;AAEJ,QAAI,YAAY;AAEhB,WAAO,UAAU;AAEjB,0BAAsB,YAAY;AAChC,UAAI,SAAS,MAAM,aAAa;AAChC,UAAI;AAEJ,WAAK,MAAM,SAAS,cAAc;AAClC,SAAG,YAAY;AACf,aAAO,GAAG;AAOV,UAAI,KAAK,WAAW,KAAK,SAAS,OAAO,aAAa,eAAe,QAAQ;AAC3E,eAAO;AAAA;AAIT,aAAO,SAAS,SAAS,QAAQ;AAAA;AAAA;AAAA;",
  "names": []
}

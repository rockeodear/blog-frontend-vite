{
  "version": 3,
  "sources": ["../unist-util-find-after/index.js", "../hast-util-to-text/index.js"],
  "sourcesContent": ["'use strict'\n\nvar convert = require('unist-util-is/convert')\n\nmodule.exports = findAfter\n\nfunction findAfter(parent, index, test) {\n  var is = convert(test)\n  var children\n  var child\n  var length\n\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node')\n  }\n\n  children = parent.children\n  length = children.length\n\n  if (index && index.type) {\n    index = children.indexOf(index)\n  }\n\n  if (isNaN(index) || index < 0 || index === Infinity) {\n    throw new Error('Expected positive finite index or child node')\n  }\n\n  while (++index < length) {\n    child = children[index]\n\n    if (is(child, index, parent)) {\n      return child\n    }\n  }\n\n  return null\n}\n", "'use strict'\n\nvar repeat = require('repeat-string')\nvar convert = require('hast-util-is-element/convert')\nvar findAfter = require('unist-util-find-after')\n\nmodule.exports = toText\n\nvar searchLineFeeds = /\\n/g\nvar searchTabOrSpaces = /[\\t ]+/g\n\nvar br = convert('br')\nvar p = convert('p')\nvar cell = convert(['th', 'td'])\nvar row = convert('tr')\n\n// Note that we don\u2019t need to include void elements here as they don\u2019t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nvar notRendered = convert([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Act as if we support scripting.\n  'noscript',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nvar blockOrCaption = convert([\n  'caption', // `table-caption`\n  // Page\n  'html',\n  'body',\n  // Flow content\n  'address',\n  'blockquote',\n  'center', // Legacy\n  'dialog',\n  'div',\n  'figure',\n  'figcaption',\n  'footer',\n  'form,',\n  'header',\n  'hr',\n  'legend',\n  'listing', // Legacy\n  'main',\n  'p',\n  'plaintext', // Legacy\n  'pre',\n  'xmp', // Legacy\n  // Sections and headings\n  'article',\n  'aside',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'hgroup',\n  'nav',\n  'section',\n  // Lists\n  'dir', // Legacy\n  'dd',\n  'dl',\n  'dt',\n  'menu',\n  'ol',\n  'ul'\n])\n\n// Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we\u2019re a\n// CSS-supporting user agent.\nfunction toText(node) {\n  var children = node.children || []\n  var block = blockOrCaption(node)\n  var whiteSpace = inferWhiteSpace(node, {})\n  var index = -1\n  var results\n  var result\n  var value\n  var count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node\u2019s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    })\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we\u2019re not supporting stylesheets so we\u2019re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we\u2019ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      innerTextCollection(children[index], index, node, {\n        whiteSpace: whiteSpace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push(repeat('\\n', count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n// <https://html.spec.whatwg.org/#inner-text-collection-steps>\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whiteSpace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node, options)\n    ]\n  }\n\n  return []\n}\n\n// Collect an element.\nfunction collectElement(node, _, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options)\n  var children = node.children || []\n  var index = -1\n  var items = []\n  var prefix\n  var suffix\n\n  // We\u2019re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node\u2019s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node\u2019s computed value of `display` is `table-row`, and node\u2019s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node\u2019s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], index, node, {\n        whiteSpace: whiteSpace,\n        breakBefore: index ? null : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node\u2019s computed value of `display` is `table-cell`, and node\u2019s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n// 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don\u2019t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\nfunction collectText(node, options) {\n  var value = String(node.value)\n  var lines = []\n  var result = []\n  var start = 0\n  var index = -1\n  var match\n  var end\n  var join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndcollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061c\\u200e\\u200f\\u202a-\\u202e\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n// 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space\u2014even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context\u2014is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var result = []\n  var start = 0\n  var match\n  var end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we\u2019re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there\u2019s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n// We don\u2019t support void elements here (so `nobr wbr` -> `normal` is ignored).\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {}\n  var inherit = options.whiteSpace || 'normal'\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre'\n    case 'nobr':\n      return 'nowrap'\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre'\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit\n    case 'textarea':\n      return 'pre-wrap'\n    default:\n      return inherit\n  }\n}\n\nfunction hidden(node) {\n  return (node.properties || {}).hidden\n}\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n"],
  "mappings": "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",
  "names": []
}

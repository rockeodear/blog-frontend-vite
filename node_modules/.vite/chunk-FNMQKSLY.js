import {
  require_convert as require_convert2
} from "./chunk-EYMLJTGX.js";
import {
  require_convert
} from "./chunk-3RIRJ6BY.js";
import {
  require_repeat_string
} from "./chunk-AWYOROPT.js";
import {
  __commonJS
} from "./chunk-XTN4ZABK.js";

// node_modules/unist-util-find-after/index.js
var require_unist_util_find_after = __commonJS({
  "node_modules/unist-util-find-after/index.js"(exports, module) {
    "use strict";
    var convert = require_convert();
    module.exports = findAfter;
    function findAfter(parent, index, test) {
      var is = convert(test);
      var children;
      var child;
      var length;
      if (!parent || !parent.type || !parent.children) {
        throw new Error("Expected parent node");
      }
      children = parent.children;
      length = children.length;
      if (index && index.type) {
        index = children.indexOf(index);
      }
      if (isNaN(index) || index < 0 || index === Infinity) {
        throw new Error("Expected positive finite index or child node");
      }
      while (++index < length) {
        child = children[index];
        if (is(child, index, parent)) {
          return child;
        }
      }
      return null;
    }
  }
});

// node_modules/hast-util-to-text/index.js
var require_hast_util_to_text = __commonJS({
  "node_modules/hast-util-to-text/index.js"(exports, module) {
    "use strict";
    var repeat = require_repeat_string();
    var convert = require_convert2();
    var findAfter = require_unist_util_find_after();
    module.exports = toText;
    var searchLineFeeds = /\n/g;
    var searchTabOrSpaces = /[\t ]+/g;
    var br = convert("br");
    var p = convert("p");
    var cell = convert(["th", "td"]);
    var row = convert("tr");
    var notRendered = convert([
      "datalist",
      "head",
      "noembed",
      "noframes",
      "rp",
      "script",
      "style",
      "template",
      "title",
      "noscript",
      hidden,
      closedDialog
    ]);
    var blockOrCaption = convert([
      "caption",
      "html",
      "body",
      "address",
      "blockquote",
      "center",
      "dialog",
      "div",
      "figure",
      "figcaption",
      "footer",
      "form,",
      "header",
      "hr",
      "legend",
      "listing",
      "main",
      "p",
      "plaintext",
      "pre",
      "xmp",
      "article",
      "aside",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hgroup",
      "nav",
      "section",
      "dir",
      "dd",
      "dl",
      "dt",
      "menu",
      "ol",
      "ul"
    ]);
    function toText(node) {
      var children = node.children || [];
      var block = blockOrCaption(node);
      var whiteSpace = inferWhiteSpace(node, {});
      var index = -1;
      var results;
      var result;
      var value;
      var count;
      if (node.type === "text" || node.type === "comment") {
        return collectText(node, {
          whiteSpace,
          breakBefore: true,
          breakAfter: true
        });
      }
      results = [];
      while (++index < children.length) {
        results = results.concat(innerTextCollection(children[index], index, node, {
          whiteSpace,
          breakBefore: index ? null : block,
          breakAfter: index < children.length - 1 ? br(children[index + 1]) : block
        }));
      }
      index = -1;
      result = [];
      while (++index < results.length) {
        value = results[index];
        if (typeof value === "number") {
          if (count !== void 0 && value > count)
            count = value;
        } else if (value) {
          if (count)
            result.push(repeat("\n", count));
          count = 0;
          result.push(value);
        }
      }
      return result.join("");
    }
    function innerTextCollection(node, index, parent, options) {
      if (node.type === "element") {
        return collectElement(node, index, parent, options);
      }
      if (node.type === "text") {
        return [
          options.whiteSpace === "normal" ? collectText(node, options) : collectPreText(node, options)
        ];
      }
      return [];
    }
    function collectElement(node, _, parent, options) {
      var whiteSpace = inferWhiteSpace(node, options);
      var children = node.children || [];
      var index = -1;
      var items = [];
      var prefix;
      var suffix;
      if (notRendered(node)) {
        return items;
      }
      if (br(node)) {
        suffix = "\n";
      } else if (row(node) && findAfter(parent, node, row)) {
        suffix = "\n";
      } else if (p(node)) {
        prefix = 2;
        suffix = 2;
      } else if (blockOrCaption(node)) {
        prefix = 1;
        suffix = 1;
      }
      while (++index < children.length) {
        items = items.concat(innerTextCollection(children[index], index, node, {
          whiteSpace,
          breakBefore: index ? null : prefix,
          breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix
        }));
      }
      if (cell(node) && findAfter(parent, node, cell)) {
        items.push("	");
      }
      if (prefix)
        items.unshift(prefix);
      if (suffix)
        items.push(suffix);
      return items;
    }
    function collectText(node, options) {
      var value = String(node.value);
      var lines = [];
      var result = [];
      var start = 0;
      var index = -1;
      var match;
      var end;
      var join;
      while (start < value.length) {
        searchLineFeeds.lastIndex = start;
        match = searchLineFeeds.exec(value);
        end = match ? match.index : value.length;
        lines.push(trimAndcollapseSpacesAndTabs(value.slice(start, end).replace(/[\u061c\u200e\u200f\u202a-\u202e\u2066-\u2069]/g, ""), options.breakBefore, options.breakAfter));
        start = end + 1;
      }
      while (++index < lines.length) {
        if (lines[index].charCodeAt(lines[index].length - 1) === 8203 || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 8203) {
          result.push(lines[index]);
          join = "";
        } else if (lines[index]) {
          if (join)
            result.push(join);
          result.push(lines[index]);
          join = " ";
        }
      }
      return result.join("");
    }
    function collectPreText(node) {
      return String(node.value);
    }
    function trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {
      var result = [];
      var start = 0;
      var match;
      var end;
      while (start < value.length) {
        searchTabOrSpaces.lastIndex = start;
        match = searchTabOrSpaces.exec(value);
        end = match ? match.index : value.length;
        if (!start && !end && match && !breakBefore) {
          result.push("");
        }
        if (start !== end) {
          result.push(value.slice(start, end));
        }
        start = match ? end + match[0].length : end;
      }
      if (start !== end && !breakAfter) {
        result.push("");
      }
      return result.join(" ");
    }
    function inferWhiteSpace(node, options) {
      var props = node.properties || {};
      var inherit = options.whiteSpace || "normal";
      switch (node.tagName) {
        case "listing":
        case "plaintext":
        case "xmp":
          return "pre";
        case "nobr":
          return "nowrap";
        case "pre":
          return props.wrap ? "pre-wrap" : "pre";
        case "td":
        case "th":
          return props.noWrap ? "nowrap" : inherit;
        case "textarea":
          return "pre-wrap";
        default:
          return inherit;
      }
    }
    function hidden(node) {
      return (node.properties || {}).hidden;
    }
    function closedDialog(node) {
      return node.tagName === "dialog" && !(node.properties || {}).open;
    }
  }
});

export {
  require_hast_util_to_text
};
//# sourceMappingURL=chunk-FNMQKSLY.js.map
